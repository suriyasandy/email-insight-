import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import win32com.client
import pythoncom
import pandas as pd
import os
import re
import gc
import threading
import locale
import logging
import json
import tempfile
from datetime import datetime, timedelta

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class EmailEntityExtractor:
    def __init__(self, root, dir_path, temp_path):
        self.out_path = dir_path
        self.temp_path = temp_path
        self.selected_columns = [
            "RoRWA", "Sales VA", "Spot RWAs", "Average RWAs", "CVA Fee Amount",
            "FVA Fee Amount", "RCVA Fee Amount", "Internal Fee Amount",
            "IM Fee Amount", "RCVA", "VA", "CVA", "PC", "FVA", "RoRWA achieved"
        ]
        
        self.root = root
        self.root.title("Email Entity Extractor")
        self.root.geometry("1300x950")
        self.root.resizable(True, True)

        # Hardcoded mailbox/folder configuration for fast UI
        self.mailbox_folders = {
            "HBEU-Rates-TA": ["Sent Items", "QTrack History 2025Q4"],
            "EXOTICSTAG HBFR-DMTC": ["Sent Items", "QTrack History 2025Q4"], 
            "FO-EURO-RATES HBFR-DMTC": ["Sent Items", "QTrack History 2025Q4"],
            "MODERIV-HSBCF HBFR-DMTC": ["Sent Items", "QTrack History 2025Q4"],
            "GMO_DARR": ["Sent Items", "QTrack History 2025Q4"],
            "HKFI Derv Flow": ["Sent Items", "QTrack History 2025Q4"]
        }

        style = ttk.Style()
        style.theme_use('clam')

        main_frame = ttk.Frame(root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        root.columnconfigure(0, weight=1) 
        root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(7, weight=1)

        # Outlook folder selection
        outlook_folder = ["Sent Items","QTrack History 2025Q4"]
        ttk.Label(main_frame, text="Select Mailbox:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.mailbox_combo_var = tk.StringVar()
        self.mailbox_combo = ttk.Combobox(main_frame, textvariable=self.mailbox_combo_var, values=list(self.mailbox_folders.keys()), width=30)
        self.mailbox_combo.grid(row=0, column=1, columnspan=6, sticky=(tk.W), pady=5, padx=(5,0))
        self.mailbox_combo.bind("<<ComboboxSelected>>", self.on_mailbox_select)

        ttk.Label(main_frame, text="Select Outlook Folder:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.folder_var = tk.StringVar()  
        self.folder_combo = ttk.Combobox(main_frame, textvariable=self.folder_var, values=[], width=30)
        self.folder_combo.grid(row=1, column=1, sticky=(tk.W), pady=5, padx=(5,0))

        # Browse for Input Trade_Id file
        ttk.Label(main_frame, text="Trade_ID Input File:").grid(row=1, column=2, sticky=tk.W, pady=2)
        self.file_path_var = tk.StringVar()
        file_entry = ttk.Entry(main_frame, textvariable=self.file_path_var, width=40)
        file_entry.grid(row=1, column=3, sticky=(tk.W, tk.E), pady=5, padx=(0, 5))
        ttk.Button(main_frame, text="Browse", command=self.browse_file).grid(row=1, column=4, pady=5)

        # Trade ID input 
        ttk.Label(main_frame, text="Trade ID:").grid(row=1, column=5, sticky=tk.W, pady=5)
        self.trade_ids_var = tk.StringVar()
        trade_id_entry = ttk.Entry(main_frame, textvariable=self.trade_ids_var, width=30)
        trade_id_entry.grid(row=1, column=6, pady=6, padx=(0, 5))

        # Entity definitions text area
        ttk.Label(main_frame, text="Entity Definitions (JSON format):").grid(row=2, column=0, sticky=tk.W, pady=5)
        self.entity_text = scrolledtext.ScrolledText(main_frame, width=90, height=10)
        self.entity_text.grid(row=2, column=1, columnspan=6, sticky=(tk.W, tk.E), pady=5)

        # Default entity pattern JSON
        package_pattern = r"(?P<TradeID>\d{7,8}[A-Z]?)\s+(?P<Currency>[A-Z]{3})\s+(?P<Amount>\d{1,3}(?:,\d{3})*\.\d{2})\s+(?P<StartDate>\d{2}/\d{2}/\d{4})\s+(?P<EndDate>\d{2}/\d{2}/\d{4})\s+(?P<Book1>\w+)\s+(?P<Book2>\w+)"

        custom_entities = {
            "entities": [
                {
                    "name": "PackageDetails",
                    "type": "pattern", 
                    "patterns": [package_pattern]
                }
            ]
        }

        self.entity_text.insert(1.0, json.dumps(custom_entities, indent=2))

        # Buttons frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=3, column=0, columnspan=7, pady=10)
        ttk.Button(button_frame, text="Extract Email Chain (.msg)", command=self.extract_email_chain).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Extract from Outlook", command=self.extract_email_chain_from_outlook).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Extract Entities", command=self.extract_entities).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Extract Tables", command=self.extract_tables).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Export to CSV", command=self.export_to_csv).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Save Config", command=self.save_config).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Load Config", command=self.load_config).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Consolidated_Results", command=self.export_consolidated_results).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Clear Results", command=self.clear_results).pack(side=tk.LEFT, padx=5)

        self.progress = ttk.Progressbar(main_frame, mode='indeterminate')
        self.progress.grid(row=4, column=0, columnspan=7, sticky=(tk.W, tk.E), pady=5)

        ttk.Label(main_frame, text="Email Chain:").grid(row=5, column=0, sticky=tk.W, pady=5)

        self.tree = ttk.Treeview(main_frame, columns=('trade_id','Subject', 'From', 'To', 'Date', 'Email Type'), show='headings')
        self.tree.heading('trade_id',text='trade_id')
        self.tree.heading('Subject', text='Subject')
        self.tree.heading('From', text='From')
        self.tree.heading('To', text='To')
        self.tree.heading('Date', text='Date')
        self.tree.heading('Email Type', text='Email Type')
        self.tree.column('trade_id',width=120)
        self.tree.column('Subject', width=200)
        self.tree.column('From', width=120)
        self.tree.column('To', width=120)
        self.tree.column('Date', width=120)
        self.tree.column('Email Type', width=80)
        self.tree.grid(row=6, column=0, columnspan=7, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        tree_scroll = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=self.tree.yview)
        tree_scroll.grid(row=6, column=7, sticky=(tk.N, tk.S))
        self.tree.configure(yscrollcommand=tree_scroll.set)

        ttk.Label(main_frame, text="Email Content:").grid(row=7, column=0, sticky=tk.W, pady=5)
        self.content_text = scrolledtext.ScrolledText(main_frame, width=80, height=20)
        self.content_text.grid(row=8, column=0, columnspan=5, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)

        ttk.Label(main_frame, text="Extracted Entities:").grid(row=7, column=5, sticky=tk.W, pady=5)
        self.entity_result_text = scrolledtext.ScrolledText(main_frame, width=40, height=20)
        self.entity_result_text.grid(row=8, column=5, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)

        self.tree.bind('<<TreeviewSelect>>', self.on_email_select)

        self.emails = []
        self.selected_email = None
        self.current_email_index = -1
        self.entity_definitions = custom_entities

        # Initialize with first mailbox selection
        if self.mailbox_folders:
            self.mailbox_combo.current(0)
            self.on_mailbox_select()

    def get_mailboxes(self):
        """Return hardcoded mailbox list - no COM scanning needed"""
        return list(self.mailbox_folders.keys())

    def get_subfolders(self, mailbox_name):
        """Return hardcoded folder list for mailbox - no COM scanning needed"""
        return self.mailbox_folders.get(mailbox_name, [])

    def on_mailbox_select(self, event=None):
        """Instantly populate folder dropdown based on selected mailbox"""
        selected_mailbox = self.mailbox_combo_var.get()
        if selected_mailbox in self.mailbox_folders:
            subfolders = self.mailbox_folders[selected_mailbox]
            self.folder_combo['values'] = subfolders
            if subfolders:
                self.folder_combo.current(0)
            else:
                self.folder_var.set('')

    def connect_to_outlook(self):
        """Connect to Outlook with selected mailbox and folder"""
        try:
            mailbox_name = self.mailbox_combo_var.get()
            folder_name = self.folder_var.get()
            # Find the mailbox by name
            outlook = win32com.client.Dispatch("Outlook.Application")
            mapi = outlook.GetNamespace("MAPI")
            mailbox = None
            for i in range(1, mapi.Folders.Count + 1):
                m = mapi.Folders.Item(i)
                if m.Name == mailbox_name:
                    mailbox = m
                    break
            if mailbox is None:
                logger.info(f"Selected {mailbox_name} Mailbox not found!")
                messagebox.showerror("Select Mailbox", "Selected mailbox not found!")
                return None
            # Now get the folder in that mailbox
            folder = None
            for j in range(1, mailbox.Folders.Count + 1):
                f = mailbox.Folders.Item(j)
                if f.Name == folder_name:
                    folder = f
                    break
            if folder is None:
                logger.info(f"Folder '{folder_name}' not found in '{mailbox_name}'!")
                messagebox.showerror("Select Folder", f"Folder '{folder_name}' not found in '{mailbox_name}'!")
                return None
            return folder
        except Exception as e:
            logger.info(f"Failed to connect to Outlook: {e}")
            messagebox.showerror("Outlook Connection Error", f"Failed to connect to Outlook: {e}")
            return None

    def get_region_datefmt_ampm(self):
        """Map the locale to a standard date format and time style for Restrict."""
        region = locale.getdefaultlocale()[0] if locale.getdefaultlocale() else ''
        # Extend this mapping as needed for your targets
        region_datefmt = {
            'en_US': ('%m/%d/%Y', True),     # MM/DD/YYYY, 12h
            'en_GB': ('%d/%m/%Y', False),    # DD/MM/YYYY, 24h
            'en_IN': ('%d-%m-%Y', False),    # DD-MM-YYYY, 24h
            'fr_FR': ('%d/%m/%Y', False),    # France
            'de_DE': ('%d.%m.%Y', False),    # Germany
            'es_ES': ('%d/%m/%Y', False),    
            'en_UK': ('%d/%m/%Y', False),
            'en_HK': ('%d/%m/%Y',True)
        }
        # Add or modify for your deployment regions!
        # Fallback: US style (12h, MM/DD/YYYY)
        date_fmt, use_ampm = region_datefmt.get(region, ('%m/%d/%Y', True))
        return date_fmt, use_ampm

    def restrict_datetime_strings(self, date_dt, date_fmt, use_ampm):
        """Return (start_time, end_time) Restrict-ready strings for a given day, region settings."""
        if use_ampm:
            am_marker = date_dt.replace(hour=1).strftime('%p')
            pm_marker = date_dt.replace(hour=13).strftime('%p')
            start_time = f"{date_dt.strftime(date_fmt)} 12:00:00 {am_marker}"
            end_time = f"{date_dt.strftime(date_fmt)} 11:59:59 {pm_marker}"
        else:
            start_time = f"{date_dt.strftime(date_fmt)} 00:00:00"
            end_time = f"{date_dt.strftime(date_fmt)} 23:59:59"
        return start_time, end_time

    def safe_items_to_list(self, items):
        """Convert Restrict result to a list, handling non-iterable cases."""
        try:
            return list(items)
        except Exception:
            if items is None:
                return []
            try:
                if getattr(items, "Subject", None) is not None:
                    return [items]
            except Exception:
                pass
            return []

    def process_items_in_batches(self, items, batch_size=150):
        """Efficiently process mail items in small batches to prevent MAPI/Outlook 'too many open objects' issues."""
        items_list = self.safe_items_to_list(items)
        if not items_list:
            return []
        all_data = []
        for i in range(0, len(items_list), batch_size):
            batch = items_list[i:i + batch_size]
            for item in batch:
                try:
                    if getattr(item, "Class", None) == 43:  # olMailItem
                        all_data.append({"item": item})
                except Exception as e:
                    logger.warning(f"Error reading batch mail: {e}")
                finally:
                    del item
            gc.collect()
        return all_data

    def extract_email_chain_from_outlook(self):
        """Main threaded extraction from Outlook"""
        trade_ids_str = None 
        df = pd.DataFrame(columns=self.selected_columns)
        if hasattr(self, "trade_ids_var") or isinstance(self.trade_ids_var, tk.StringVar):
            trade_ids_str = self.trade_ids_var.get().strip()
        if not trade_ids_str:
            file_path = self.file_path_var.get().strip()
            if not file_path or not os.path.exists(file_path):
                messagebox.showwarning("Input Error", "Please upload a valid file/input trade_id")
                return
            self.trade_ids_var.set(self.process_trade_file(file_path))
            trade_ids_str = self.trade_ids_var.get().strip()

        trade_ids = [tid.strip() for tid in re.split(",|\\s", trade_ids_str) if tid.strip()]
        
        self.progress.start()
        self.clear_results()
        self.emails = []
        self.unfound_trades = []

        def worker():
            pythoncom.CoInitialize()  # Initialize COM for this thread
            try:
                folder = self.connect_to_outlook()
                if not folder:
                    self.root.after(0, lambda: self.finish_extraction([], "Could not connect to folder"))
                    return

                today = datetime.now()
                days_back = 3
                # --- Hardcoded region-based restrict format ---
                date_fmt, use_ampm = self.get_region_datefmt_ampm()
                logger.info(f"Detected locale datefmt: {date_fmt}, Use AM/PM: {use_ampm}")
                pattern = re.compile("|".join(re.escape(tid) for tid in trade_ids))
                all_items = []

                for days_ago in range(1, days_back + 1):
                    d = today - timedelta(days=days_ago)
                    start_time, end_time = self.restrict_datetime_strings(d, date_fmt, use_ampm)
                    filter_str = f"[ReceivedTime] >= '{start_time}' AND [ReceivedTime] <= '{end_time}'"
                    logger.info(f"Trying filter: {filter_str}")
                    items = folder.Items.Restrict(filter_str)
                    items_list = self.process_items_in_batches(items, batch_size=150)
                    # fallback if AM/PM case doesn't match
                    if not items_list and use_ampm:
                        am_l = d.replace(hour=1).strftime('%p').lower()
                        pm_l = d.replace(hour=13).strftime('%p').lower()
                        start_time_l = f"{d.strftime(date_fmt)} 12:00:00 {am_l}"
                        end_time_l = f"{d.strftime(date_fmt)} 11:59:59 {pm_l}"
                        filter_str_l = f"[ReceivedTime] >= '{start_time_l}' AND [ReceivedTime] <= '{end_time_l}'"
                        logger.info(f"Trying filter (lowercase): {filter_str_l}")
                        items = folder.Items.Restrict(filter_str_l)
                        items_list = self.process_items_in_batches(items, batch_size=150)
                    if items_list:
                        logger.info(f"Found {len(items_list)} emails for {d.strftime(date_fmt)}")
                        all_items.extend([entry["item"] for entry in items_list])
                    else:
                        logger.info(f"No emails for {d.strftime(date_fmt)}")

                all_emails = []
                # For each Trade ID, gather emails and tag them
                for trade_id in trade_ids:
                    matched = []
                    for item in all_items:
                        try:
                            if getattr(item, "Class", None) == 43:
                                subject = item.Subject or ""
                                body = item.Body or ""
                                html_body = ""
                                try:
                                    html_body = item.HTMLBody
                                except Exception:
                                    pass
                                if (trade_id in subject or trade_id in body or (html_body and trade_id in html_body)):
                                    content_text = body if body else BeautifulSoup(html_body, "html.parser").get_text("\n") if html_body else ""
                                    matched.append({
                                        'trade_id': trade_id,
                                        'subject': subject,
                                        'sender': getattr(item, "SenderName", ""),
                                        'recipient': getattr(item, "To", ""),
                                        'date': item.ReceivedTime.strftime("%Y-%m-%d %H:%M:%S") if item.ReceivedTime else "",
                                        'body': body,
                                        'html_body': html_body
                                    })
                        except Exception as e:
                            logger.warning(f"Error processing matched item: {e}")
                    
                    self.emails.append({"trade_id": trade_id, "emails": matched})
                    all_emails.extend(matched)

                gc.collect()
                self.root.after(0, lambda: self.finish_extraction(all_emails, None))
            except Exception as e:
                gc.collect()
                self.root.after(0, lambda: self.finish_extraction([], str(e)))
            finally:
                pythoncom.CoUninitialize()  # Clean up COM

        threading.Thread(target=worker, daemon=True).start()

    def finish_extraction(self, all_emails, error):
        """Handle extraction completion on main thread"""
        self.progress.stop()
        if error:
            messagebox.showerror("Extraction Error", f"Failed to extract emails: {error}")
        else:
            # populate tree with all emails regardless of trade id with trade id column
            for idx, mail in enumerate(all_emails):
                email_type = "Original"
                if idx > 0:
                    subj = mail['subject'].lower()
                    if "re:" in subj:
                        email_type = f"Reply {idx}"
                    elif "fw:" in subj or "fwd:" in subj:
                        email_type = f"Forward {idx}"
                    else:
                        email_type = f"Email {idx}"

                self.tree.insert('', 'end', iid=str(idx), values=(
                    mail['trade_id'],
                    mail['subject'][:30] + "..." if len(mail['subject']) > 30 else mail['subject'],
                    mail['sender'][:20] + "..." if len(mail['sender']) > 20 else mail['sender'],
                    mail['recipient'][:20] + "..." if len(mail['recipient']) > 20 else mail['recipient'],
                    mail['date'],
                    email_type
                ))

            found_trade_ids = set(mail['trade_id'] for mail in all_emails)
            self.unfound_trades = [tid for tid in [tid.strip() for tid in re.split(",|\\s", self.trade_ids_var.get().strip()) if tid.strip()] if tid not in found_trade_ids]
            logger.info(f"{self.unfound_trades} - Not Found In Email")
            for tid in self.unfound_trades:
                filename = f"{tid}_email_entities_export_{datetime.now().strftime('%m_%d_%Y')}.csv"
                out_file = os.path.join(self.temp_path, filename)
                df.to_csv(out_file, index=False)
            messagebox.showinfo("Success", f"Loaded {len(all_emails)} emails across {len(found_trade_ids)} Trade IDs.")

    # Keep all your existing functions unchanged
    def process_trade_file(self, file_path):
        """Process trade ID file - keep existing logic"""
        # Your existing implementation
        pass

    def browse_file(self):
        """Browse for file - keep existing logic"""
        # Your existing implementation
        pass

    def extract_email_chain(self):
        """Extract from .msg files - keep existing logic"""  
        # Your existing implementation
        pass

    def sort_emails_by_date(self):
        """Sort emails by date - keep existing logic"""
        # Your existing implementation
        pass

    def process_msg_file(self, file_path):
        """Process MSG file - keep existing logic"""
        # Your existing implementation
        pass

    def extract_email_data(self, msg):
        """Extract email data from MSG - keep existing logic"""
        # Your existing implementation
        pass

    def extract_emails_from_body(self, body):
        """Extract emails from body - keep existing logic"""
        # Your existing implementation
        pass

    def extract_text_content(self, plain_text, html_content):
        """Extract text content - keep existing logic"""
        # Your existing implementation
        pass

    def on_email_select(self, event):
        """Handle email selection in tree"""
        selection = self.tree.selection()
        if not selection:
            return
        email_index = int(selection[0])
        self.current_email_index = email_index
        
        # Find the email in the flattened list
        flat_emails = []
        for entry in self.emails:
            flat_emails.extend(entry["emails"])
        
        if 0 <= email_index < len(flat_emails):
            email_data = flat_emails[email_index]
            content = f"Trade ID: {email_data['trade_id']}\n"
            content += f"From: {email_data['sender']}\n"
            content += f"To: {email_data['recipient']}\n"
            content += f"Date: {email_data['date']}\n"
            content += f"Subject: {email_data['subject']}\n"
            content += "-" * 50 + "\n"
            content += email_data['body']
            self.content_text.delete(1.0, tk.END)
            self.content_text.insert(1.0, content)
            self.entity_result_text.delete(1.0, tk.END)

    def extract_entities(self):
        """Extract entities - keep existing logic"""
        # Your existing implementation
        pass

    def extract_with_patterns(self, content, patterns):
        """Extract with patterns - keep existing logic"""
        # Your existing implementation
        pass

    def extract_with_gazetteer(self, content, gazetteer_values):
        """Extract with gazetteer - keep existing logic"""
        # Your existing implementation
        pass

    def clear_results(self):
        """Clear all results"""
        self.tree.delete(*self.tree.get_children())
        self.content_text.delete(1.0, tk.END)
        self.entity_result_text.delete(1.0, tk.END)
        self.emails = []
        self.current_email_index = -1

    def export_to_csv(self):
        """Export to CSV - keep existing logic"""
        # Your existing implementation
        pass

    def save_config(self):
        """Save config - keep existing logic"""
        # Your existing implementation
        pass

    def load_config(self):
        """Load config - keep existing logic"""
        # Your existing implementation
        pass

    def extract_tables(self):
        """Extract tables - keep existing logic"""
        # Your existing implementation
        pass

    def show_tables_popup(self, all_tables):
        """Show tables popup - keep existing logic"""
        # Your existing implementation
        pass

    def extract_tables_from_html(self, html_content):
        """Extract tables from HTML - keep existing logic"""
        # Your existing implementation
        pass

    def export_tables_to_csv(self, all_tables):
        """Export tables to CSV - keep existing logic"""
        # Your existing implementation
        pass

    def copy_files(self, src_dir, dst_dir):
        """Copy files - keep existing logic"""
        # Your existing implementation
        pass

    def export_consolidated_results(self):
        """Export consolidated results - keep existing logic"""
        # Your existing implementation
        pass

def delete_dir_if_exists(dir_path):
    """Delete directory if exists - keep existing logic"""
    # Your existing implementation
    pass

def fetchfile():
    logger.info(f"Mail Harvester Bot triggered - User:{os.getlogin()}")
    today = datetime.today()
    dir_path = os.path.join(
        "//hbap.adroot.hsbc.in/B4/Deptdata/GMO_DARR/TDO/QMRC/Genio/Email_Harvester",
        str(today.year),
        str(today.month).zfill(2),  # Ensures month is two digits
        str(today.day).zfill(2),   # Ensures day is two digits
        os.getlogin()              # Ensures day is two digits
    )
    os.makedirs(dir_path, exist_ok=True)
    logger.info(f"Output Directory : {dir_path}")
    temp_path = os.path.join(
        os.getcwd(),
        "Results",
        str(today.year),
        str(today.month).zfill(2),  # Ensures month is two digits
        str(today.day).zfill(2),   # Ensures day is two digits
    )
    os.makedirs(temp_path, exist_ok=True)
    logger.info(f"Output Directory : {temp_path}")
    root = tk.Tk()
    app = EmailEntityExtractor(root, dir_path, temp_path)
    root.mainloop()
    logger.info(f"Mail Harvester Bot Run Completed - User:{os.getlogin()}")
    for file in os.listdir(self.temp_path):
        file_path = os.path.join(self.temp_path, file)
        if os.path.isfile(file_path):
            os.remove(file_path)
    delete_dir_if_exists(temp_path)

if __name__ == "__main__":
    fetchfile()
