import re
import gc
from itertools import islice
from datetime import datetime, timedelta

def safe_items_to_list(items):
    """Convert Restrict result to a list, handling non-iterable cases."""
    try:
        return list(items)
    except Exception:
        # If not iterable, check if it's a single MailItem or None
        if items is None:
            return []
        try:
            # Try to access a MailItem property
            if getattr(items, "Subject", None) is not None:
                return [items]
        except Exception:
            pass
        return []

def process_items_in_batches(items, batch_size=150):
    """
    Efficiently process mail items in small batches
    to prevent MAPI/Outlook 'too many open objects' issues.
    """
    items_list = safe_items_to_list(items)
    if not items_list:
        return []
    
    all_data = []
    batch_idx = 1
    for i in range(0, len(items_list), batch_size):
        batch = items_list[i:i + batch_size]
        for item in batch:
            try:
                if getattr(item, "Class", None) == 43:  # olMailItem
                    all_data.append({"item": item})
            except Exception as e:
                print("Error reading batch mail:", e)
            finally:
                del item
        gc.collect()
        batch_idx += 1
    return all_data

def extract_email_chain_from_outlook(self):
    trade_ids_str = None
    df = pd.DataFrame(columns=self.selected_columns)
    if hasattr(self, "trade_ids_var") or isinstance(self.trade_ids_var, tk.StringVar):
        trade_ids_str = self.trade_ids_var.get().strip()
    if not trade_ids_str:
        file_path = self.file_path_var.get().strip()
        if not file_path or not os.path.exists(file_path):
            messagebox.showwarning("Input Error", "Please upload a valid file/input trade_id")
            return
        self.trade_ids_var.set(self.process_trade_file(file_path))
        trade_ids_str = self.trade_ids_var.get().strip()

    trade_ids = [tid.strip() for tid in re.split(",|\\s", trade_ids_str) if tid.strip()]
    folder = self.connect_to_outlook()
    if not folder:
        return

    self.progress.start()
    self.clear_results()
    self.emails = []
    self.unfound_trades = []

    try:
        today = datetime.now()
        days_back = 3

        date_fmt, use_ampm = self.get_region_datefmt_ampm()
        pattern = re.compile("|".join(re.escape(tid) for tid in trade_ids))
        all_items = []

        for days_ago in range(1, days_back + 1):
            d = today - timedelta(days=days_ago)
            start_time, end_time = self.restrict_datetime_strings(d, date_fmt, use_ampm)
            filter_str = f"[ReceivedTime] >= '{start_time}' AND [ReceivedTime] <= '{end_time}'"
            logger.info(f"Trying filter: {filter_str}")
            items = folder.Items.Restrict(filter_str)
            items_list = process_items_in_batches(items, batch_size=150)
            if not items_list and use_ampm:
                # Fallback: case-insensitive AM/PM
                am_l = d.replace(hour=1).strftime('%p').lower()
                pm_l = d.replace(hour=13).strftime('%p').lower()
                start_time_l = f"{d.strftime(date_fmt)} 12:00:00 {am_l}"
                end_time_l = f"{d.strftime(date_fmt)} 11:59:59 {pm_l}"
                filter_str_l = f"[ReceivedTime] >= '{start_time_l}' AND [ReceivedTime] <= '{end_time_l}'"
                logger.info(f"Trying filter: {filter_str_l}")
                items = folder.Items.Restrict(filter_str_l)
                items_list = process_items_in_batches(items, batch_size=150)
            if items_list:
                logger.info(f"Found {len(items_list)} emails for {d.strftime(date_fmt)}")
                all_items.extend([entry["item"] for entry in items_list])
            else:
                logger.info(f"No emails for {d.strftime(date_fmt)}")

        # For each Trade ID, gather emails...
        for trade_id in trade_ids:
            matched = []
            for item in all_items:
                try:
                    if getattr(item, "Class", None) == 43:
                        subject = item.Subject or ""
                        body = item.Body or ""
                        html_body = ""
                        try:
                            html_body = item.HTMLBody
                        except Exception:
                            pass
                        if (trade_id in subject or trade_id in body or (html_body and trade_id in html_body)):
                            matched.append({
                                'trade_id': trade_id,
                                'subject': subject,
                                'sender': getattr(item, "SenderName", ""),
                                'recipient': getattr(item, "To", ""),
                                'date': item.ReceivedTime.strftime("%Y-%m-%d %H:%M:%S") if item.ReceivedTime else "",
                                'body': body,
                                'html_body': html_body,
                            })
                except Exception as e:
                    logger.warning(f"Error processing matched item: {e}")
            self.emails.append({"trade_id": trade_id, "emails": matched})

        # Compile final result for your displayâ€”flatten as before
        all_emails = []
        for entry in self.emails:
            all_emails.extend(entry["emails"])

        # Populate tree and finalize (your existing logic)
        found_trade_ids = set(mail['trade_id'] for mail in all_emails)
        self.unfound_trades = [tid for tid in trade_ids if tid not in found_trade_ids]
        logger.info(f"{self.unfound_trades} - Not Found In Email")
        
        for idx, mail in enumerate(all_emails):
            email_type = "Original"
            subj = mail['subject'].lower()
            if "re:" in subj:
                email_type = f"Reply {idx}"
            elif "fw:" in subj or "fwd:" in subj:
                email_type = f"Forward {idx}"
            else:
                email_type = f"Email {idx}"
            self.tree.insert('', 'end', iid=str(idx), values=(
                mail['trade_id'],
                mail['subject'][:30] + "..." if len(mail['subject']) > 30 else mail['subject'],
                mail['sender'][:20] + "..." if len(mail['sender']) > 20 else mail['sender'],
                mail['recipient'][:20] + "..." if len(mail['recipient']) > 20 else mail['recipient'],
                mail['date'],
                email_type
            ))

        messagebox.showinfo("Success", f"Loaded {len(all_emails)} emails across {len(trade_ids)} Trade IDs.")

    except Exception as e:
        messagebox.showerror("Extraction Error", f"Failed to extract emails:\n{e}")
    finally:
        self.progress.stop()
        gc.collect()
