import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import pandas as pd
from bs4 import BeautifulSoup
import os
import re
import json
import extract_msg
import html2text
import tempfile

class EmailEntityExtractor:
    def __init__(self, root):
        self.root = root
        self.root.title("Email Entity Extractor")
        self.root.geometry("1200x900")
        self.root.resizable(True, True)
        
        # Configure style
        style = ttk.Style()
        style.theme_use('clam')
        
        # Create main frame
        main_frame = ttk.Frame(root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        root.columnconfigure(0, weight=1)
        root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(7, weight=1)
        
        # File selection
        ttk.Label(main_frame, text="MSG File:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.file_path_var = tk.StringVar()
        file_entry = ttk.Entry(main_frame, textvariable=self.file_path_var, width=50)
        file_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=5, padx=(0, 5))
        ttk.Button(main_frame, text="Browse", command=self.browse_file).grid(row=0, column=2, pady=5)
        
        # Entity definitions
        ttk.Label(main_frame, text="Entity Definitions (JSON format):").grid(row=1, column=0, sticky=tk.W, pady=5)
        
        # Text area for entity definitions
        self.entity_text = scrolledtext.ScrolledText(main_frame, width=60, height=10)
        self.entity_text.grid(row=1, column=1, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        # Load default entity patterns
        default_entities = {
            "entities": [
                {
                    "name": "Trade ID",
                    "type": "pattern",
                    "patterns": [
                        "Trade\\s*ID[:\s]*([A-Z0-9-]+)",
                        "TRADE\\s*[#]?\\s*([A-Z0-9-]+)",
                        "ID\\s*[:\s]\\s*([A-Z0-9-]+)"
                    ]
                },
                {
                    "name": "Date",
                    "type": "pattern",
                    "patterns": [
                        "Date[:\s]*(\d{1,2}[/-]\d{1,2}[/-]\d{2,4})",
                        "(\d{1,2}[/-]\d{1,2}[/-]\d{2,4})"
                    ]
                },
                {
                    "name": "Quantity",
                    "type": "pattern",
                    "patterns": [
                        "Quantity[:\s]*(\d+(?:\.\d+)?)",
                        "Qty[:\s]*(\d+(?:\.\d+)?)",
                        "(\d+(?:\.\d+)?)\\s*(?:shares|units)"
                    ]
                },
                {
                    "name": "Price",
                    "type": "pattern",
                    "patterns": [
                        "Price[:\s]*(\$?\d+(?:\.\d+)?)",
                        "@\\s*(\$?\d+(?:\.\d+)?)",
                        "(\$?\d+(?:\.\d+)?)\\s*per\\s*(?:share|unit)"
                    ]
                },
                {
                    "name": "Action",
                    "type": "gazetteer",
                    "values": ["Buy", "Sell", "Hold", "Execute", "Cancel"]
                },
                {
                    "name": "Status",
                    "type": "gazetteer",
                    "values": ["Pending", "Completed", "Rejected", "Confirmed", "Settled"]
                }
            ]
        }
        
        self.entity_text.insert(1.0, json.dumps(default_entities, indent=2))
        
        # Buttons frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=2, column=0, columnspan=3, pady=10)
        
        ttk.Button(button_frame, text="Extract Email Chain", command=self.extract_email_chain).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Extract Entities", command=self.extract_entities).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Clear Results", command=self.clear_results).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Export to CSV", command=self.export_to_csv).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Save Config", command=self.save_config).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Load Config", command=self.load_config).pack(side=tk.LEFT, padx=5)
        
        # Progress bar
        self.progress = ttk.Progressbar(main_frame, mode='indeterminate')
        self.progress.grid(row=3, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=5)
        
        # Email chain area
        ttk.Label(main_frame, text="Email Chain:").grid(row=4, column=0, sticky=tk.W, pady=5)
        
        # Treeview for email chain
        self.tree = ttk.Treeview(main_frame, columns=('Subject', 'From', 'To', 'Date', 'Email Type'), show='headings')
        self.tree.heading('Subject', text='Subject')
        self.tree.heading('From', text='From')
        self.tree.heading('To', text='To')
        self.tree.heading('Date', text='Date')
        self.tree.heading('Email Type', text='Email Type')
        self.tree.column('Subject', width=200)
        self.tree.column('From', width=120)
        self.tree.column('To', width=120)
        self.tree.column('Date', width=120)
        self.tree.column('Email Type', width=80)
        self.tree.grid(row=5, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Add scrollbar to treeview
        tree_scroll = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=self.tree.yview)
        tree_scroll.grid(row=5, column=3, sticky=(tk.N, tk.S))
        self.tree.configure(yscrollcommand=tree_scroll.set)
        
        # Email content area
        ttk.Label(main_frame, text="Email Content:").grid(row=6, column=0, sticky=tk.W, pady=5)
        
        self.content_text = scrolledtext.ScrolledText(main_frame, width=80, height=15)
        self.content_text.grid(row=7, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Extracted entities area
        ttk.Label(main_frame, text="Extracted Entities:").grid(row=6, column=2, sticky=tk.W, pady=5)
        
        self.entity_result_text = scrolledtext.ScrolledText(main_frame, width=40, height=15)
        self.entity_result_text.grid(row=7, column=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Bind selection event
        self.tree.bind('<<TreeviewSelect>>', self.on_email_select)
        
        # Store extracted data
        self.emails = []
        self.current_email_index = -1
        self.entity_definitions = default_entities
        
    def browse_file(self):
        file_path = filedialog.askopenfilename(
            title="Select MSG File",
            filetypes=[("Outlook MSG Files", "*.msg"), ("All Files", "*.*")]
        )
        if file_path:
            self.file_path_var.set(file_path)
        
    def extract_email_chain(self):
        file_path = self.file_path_var.get().strip()
        
        if not file_path or not os.path.exists(file_path):
            messagebox.showwarning("Input Error", "Please select a valid MSG file")
            return
            
        self.progress.start()
        self.clear_results()
        
        try:
            # Process the MSG file
            self.emails = self.process_msg_file(file_path)
            
            # Display email chain in treeview
            for i, email_data in enumerate(self.emails):
                email_type = "Original"
                if i > 0:
                    email_type = f"Reply {i}" if "re:" in email_data['subject'].lower() else f"Forward {i}"
                
                self.tree.insert('', 'end', iid=str(i), values=(
                    email_data['subject'][:30] + "..." if len(email_data['subject']) > 30 else email_data['subject'],
                    email_data['sender'][:20] + "..." if len(email_data['sender']) > 20 else email_data['sender'],
                    email_data['recipient'][:20] + "..." if len(email_data['recipient']) > 20 else email_data['recipient'],
                    email_data['date'],
                    email_type
                ))
            
            if not self.emails:
                messagebox.showinfo("No Emails", "No emails found in the MSG file")
            else:
                messagebox.showinfo("Success", f"Found {len(self.emails)} emails in the chain")
                
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {str(e)}")
        finally:
            self.progress.stop()
            
    def process_msg_file(self, file_path):
        emails = []
        
        try:
            # Open the MSG file
            msg = extract_msg.Message(file_path)
            
            # Extract the main email
            main_email = self.extract_email_data(msg)
            if main_email:
                emails.append(main_email)
            
            # Check for embedded emails (replies/forwards in the body)
            body_emails = self.extract_emails_from_body(main_email['body'] if main_email else "")
            emails.extend(body_emails)
            
            # Check for attachments that might be emails
            if hasattr(msg, 'attachments'):
                for attachment in msg.attachments:
                    if attachment.type == 'msg':
                        try:
                            # Save attachment to temporary file
                            with tempfile.NamedTemporaryFile(suffix='.msg', delete=False) as temp_file:
                                temp_path = temp_file.name
                            
                            with open(temp_path, 'wb') as f:
                                f.write(attachment.data)
                            
                            # Recursively process the attached MSG file
                            attached_emails = self.process_msg_file(temp_path)
                            emails.extend(attached_emails)
                            
                            # Clean up
                            os.unlink(temp_path)
                            
                        except Exception as e:
                            print(f"Error processing attachment: {e}")
            
            # Close the message
            msg.close()
            
        except Exception as e:
            print(f"Error processing MSG file: {e}")
            
        return emails
    
    def extract_email_data(self, msg):
        try:
            subject = msg.subject or ""
            body = msg.body or ""
            html_body = msg.htmlBody or ""
            
            # Extract text content
            text_content = self.extract_text_content(body, html_body)
            
            # Get sender information
            sender = msg.sender or "Unknown"
            
            # Get recipient information
            recipient = ""
            if hasattr(msg, 'recipients'):
                try:
                    recipient = ", ".join([r.name for r in msg.recipients if hasattr(r, 'name')])
                except:
                    recipient = "Unknown"
            
            # Get date
            date = msg.date.strftime("%Y-%m-%d %H:%M:%S") if msg.date else "Unknown"
            
            # Store email data
            email_data = {
                'subject': subject,
                'sender': sender,
                'recipient': recipient,
                'date': date,
                'body': text_content,
                'html_body': html_body
            }
            
            return email_data
            
        except Exception as e:
            print(f"Error extracting email data: {e}")
            return None
    
    def extract_emails_from_body(self, body):
        emails = []
        
        # Look for email separators and extract individual emails
        email_patterns = [
            r'From:.*?Subject:.*?Date:.*?(?=From:|Subject:|Date:|$)',
            r'-----Original Message-----.*?-----',
            r'On.*wrote:.*?From:.*?Subject:',
        ]
        
        for pattern in email_patterns:
            matches = re.finditer(pattern, body, re.DOTALL | re.IGNORECASE)
            for match in matches:
                email_text = match.group(0)
                
                # Extract email details from the text
                sender_match = re.search(r'From:\s*(.*?)(?=\n|$)', email_text, re.IGNORECASE)
                recipient_match = re.search(r'To:\s*(.*?)(?=\n|$)', email_text, re.IGNORECASE)
                subject_match = re.search(r'Subject:\s*(.*?)(?=\n|$)', email_text, re.IGNORECASE)
                date_match = re.search(r'Date:\s*(.*?)(?=\n|$)', email_text, re.IGNORECASE)
                
                # Find the body content (after headers)
                body_start = max(
                    email_text.find('\n\n') if '\n\n' in email_text else 0,
                    email_text.find('\r\n\r\n') if '\r\n\r\n' in email_text else 0
                )
                
                email_body = email_text[body_start:].strip() if body_start > 0 else email_text
                
                email_data = {
                    'subject': subject_match.group(1) if subject_match else "No Subject",
                    'sender': sender_match.group(1) if sender_match else "Unknown",
                    'recipient': recipient_match.group(1) if recipient_match else "Unknown",
                    'date': date_match.group(1) if date_match else "Unknown",
                    'body': email_body,
                    'html_body': ""
                }
                
                emails.append(email_data)
                
        return emails
    
    def extract_text_content(self, plain_text, html_content):
        if plain_text:
            return plain_text
        
        if html_content:
            try:
                # Use html2text to convert HTML to plain text
                h = html2text.HTML2Text()
                h.ignore_links = False
                return h.handle(html_content)
            except Exception as e:
                print(f"Error converting HTML to text: {e}")
                return html_content
                
        return ""
    
    def on_email_select(self, event):
        selection = self.tree.selection()
        if not selection:
            return
            
        email_index = int(selection[0])
        self.current_email_index = email_index
        
        if 0 <= email_index < len(self.emails):
            email_data = self.emails[email_index]
            
            # Display email content
            content = f"From: {email_data['sender']}\n"
            content += f"To: {email_data['recipient']}\n"
            content += f"Date: {email_data['date']}\n"
            content += f"Subject: {email_data['subject']}\n"
            content += "-" * 50 + "\n"
            content += email_data['body']
            
            self.content_text.delete(1.0, tk.END)
            self.content_text.insert(1.0, content)
            
            # Clear entities text
            self.entity_result_text.delete(1.0, tk.END)
    
    def extract_entities(self):
        if self.current_email_index == -1 or not self.emails:
            messagebox.showwarning("No Selection", "Please select an email from the chain first")
            return
            
        # Parse entity definitions from JSON
        try:
            entity_json = self.entity_text.get(1.0, tk.END).strip()
            self.entity_definitions = json.loads(entity_json)
        except Exception as e:
            messagebox.showerror("Error", f"Invalid JSON format: {str(e)}")
            return
            
        email_data = self.emails[self.current_email_index]
        email_body = email_data['body']
        
        # Extract entities
        entities = self.extract_entities_from_content(email_body, self.entity_definitions)
        
        # Display entities
        self.entity_result_text.delete(1.0, tk.END)
        if entities:
            for entity_name, values in entities.items():
                if values:
                    self.entity_result_text.insert(tk.END, f"{entity_name}:\n")
                    for value in values:
                        self.entity_result_text.insert(tk.END, f"  - {value}\n")
                    self.entity_result_text.insert(tk.END, "\n")
        else:
            self.entity_result_text.insert(tk.END, "No entities found in this email")
    
    def extract_entities_from_content(self, content, entity_definitions):
        entities = {}
        
        for entity_def in entity_definitions.get("entities", []):
            entity_name = entity_def.get("name", "")
            entity_type = entity_def.get("type", "")
            
            if entity_type == "pattern":
                patterns = entity_def.get("patterns", [])
                values = self.extract_with_patterns(content, patterns)
                if values:
                    entities[entity_name] = values
            
            elif entity_type == "gazetteer":
                gazetteer_values = entity_def.get("values", [])
                values = self.extract_with_gazetteer(content, gazetteer_values)
                if values:
                    entities[entity_name] = values
                    
        return entities
    
    def extract_with_patterns(self, content, patterns):
        values = []
        
        for pattern in patterns:
            try:
                matches = re.findall(pattern, content, re.IGNORECASE)
                for match in matches:
                    if isinstance(match, tuple):
                        # If the pattern has groups, take the first group
                        value = match[0].strip() if match[0] else ""
                    else:
                        value = match.strip()
                    
                    if value and value not in values:
                        values.append(value)
            except Exception as e:
                print(f"Error with pattern {pattern}: {e}")
                
        return values
    
    def extract_with_gazetteer(self, content, gazetteer_values):
        values = []
        
        for value in gazetteer_values:
            # Look for the value in the content (case-insensitive)
            if re.search(r'\b' + re.escape(value) + r'\b', content, re.IGNORECASE):
                if value not in values:
                    values.append(value)
                    
        return values
    
    def clear_results(self):
        self.tree.delete(*self.tree.get_children())
        self.content_text.delete(1.0, tk.END)
        self.entity_result_text.delete(1.0, tk.END)
        self.emails = []
        self.current_email_index = -1
    
    def export_to_csv(self):
        if not self.emails:
            messagebox.showwarning("No Data", "No emails to export")
            return
            
        try:
            # Parse entity definitions from JSON
            try:
                entity_json = self.entity_text.get(1.0, tk.END).strip()
                entity_definitions = json.loads(entity_json)
            except Exception as e:
                messagebox.showerror("Error", f"Invalid JSON format: {str(e)}")
                return
            
            # Create a DataFrame with all extracted data
            all_data = []
            for i, email_data in enumerate(self.emails):
                # Extract entities for this email
                entities = self.extract_entities_from_content(email_data['body'], entity_definitions)
                
                # Create a row for this email
                row_data = {
                    'Email_Index': i,
                    'Subject': email_data['subject'],
                    'From': email_data['sender'],
                    'To': email_data['recipient'],
                    'Date': email_data['date'],
                    'Body_Preview': email_data['body'][:100] + "..." if len(email_data['body']) > 100 else email_data['body']
                }
                
                # Add extracted entities
                for entity_name, values in entities.items():
                    row_data[entity_name] = ", ".join(values) if values else ""
                
                all_data.append(row_data)
            
            df = pd.DataFrame(all_data)
            
            # Save to CSV
            filename = f"email_entities_export.csv"
            df.to_csv(filename, index=False)
            
            messagebox.showinfo("Success", f"Data exported to {filename}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export data: {str(e)}")
    
    def save_config(self):
        try:
            entity_json = self.entity_text.get(1.0, tk.END).strip()
            # Validate JSON
            json.loads(entity_json)
            
            file_path = filedialog.asksaveasfilename(
                title="Save Entity Configuration",
                defaultextension=".json",
                filetypes=[("JSON Files", "*.json"), ("All Files", "*.*")]
            )
            
            if file_path:
                with open(file_path, 'w') as f:
                    f.write(entity_json)
                messagebox.showinfo("Success", "Configuration saved successfully")
                
        except Exception as e:
            messagebox.showerror("Error", f"Invalid JSON or save error: {str(e)}")
    
    def load_config(self):
        file_path = filedialog.askopenfilename(
            title="Load Entity Configuration",
            filetypes=[("JSON Files", "*.json"), ("All Files", "*.*")]
        )
        
        if file_path:
            try:
                with open(file_path, 'r') as f:
                    config_data = json.load(f)
                
                self.entity_text.delete(1.0, tk.END)
                self.entity_text.insert(1.0, json.dumps(config_data, indent=2))
                messagebox.showinfo("Success", "Configuration loaded successfully")
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load configuration: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    app = EmailEntityExtractor(root)
    root.mainloop()
