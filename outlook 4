import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import pandas as pd
from bs4 import BeautifulSoup
import os
import re
import extract_msg
import html2text
import email
from email import policy
from email.parser import BytesParser
import tempfile

class EmailChainExtractor:
    def __init__(self, root):
        self.root = root
        self.root.title("Email Chain Extractor")
        self.root.geometry("1200x900")
        self.root.resizable(True, True)
        
        # Configure style
        style = ttk.Style()
        style.theme_use('clam')
        
        # Create main frame
        main_frame = ttk.Frame(root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        root.columnconfigure(0, weight=1)
        root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(7, weight=1)
        
        # File selection
        ttk.Label(main_frame, text="MSG File:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.file_path_var = tk.StringVar()
        file_entry = ttk.Entry(main_frame, textvariable=self.file_path_var, width=50)
        file_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=5, padx=(0, 5))
        ttk.Button(main_frame, text="Browse", command=self.browse_file).grid(row=0, column=2, pady=5)
        
        # Attribute definitions
        ttk.Label(main_frame, text="Attribute Definitions (label:pattern):").grid(row=1, column=0, sticky=tk.W, pady=5)
        
        # Text area for attribute definitions
        self.attribute_text = scrolledtext.ScrolledText(main_frame, width=60, height=8)
        self.attribute_text.grid(row=1, column=1, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        # Load default attribute patterns
        default_attributes = """Trade ID:Trade\s*ID[:\s]*([A-Z0-9-]+)
Date:Date[:\s]*(\d{1,2}[/-]\d{1,2}[/-]\d{2,4})
Time:Time[:\s]*(\d{1,2}:\d{2}\s*(?:AM|PM)?)
Quantity:Quantity[:\s]*(\d+(?:\.\d+)?)
Price:Price[:\s]*(\$?\d+(?:\.\d+)?)
Symbol:Symbol[:\s]*([A-Z]+)
Action:Action[:\s]*(Buy|Sell|Hold)
Status:Status[:\s]*(Pending|Completed|Rejected)"""
        
        self.attribute_text.insert(1.0, default_attributes)
        
        # Buttons frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=2, column=0, columnspan=3, pady=10)
        
        ttk.Button(button_frame, text="Extract Email Chain", command=self.extract_email_chain).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Extract Attributes", command=self.extract_attributes).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Clear Results", command=self.clear_results).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Export to CSV", command=self.export_to_csv).pack(side=tk.LEFT, padx=5)
        
        # Progress bar
        self.progress = ttk.Progressbar(main_frame, mode='indeterminate')
        self.progress.grid(row=3, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=5)
        
        # Email chain area
        ttk.Label(main_frame, text="Email Chain:").grid(row=4, column=0, sticky=tk.W, pady=5)
        
        # Treeview for email chain
        self.tree = ttk.Treeview(main_frame, columns=('Subject', 'From', 'Date', 'Email Type'), show='headings')
        self.tree.heading('Subject', text='Subject')
        self.tree.heading('From', text='From')
        self.tree.heading('Date', text='Date')
        self.tree.heading('Email Type', text='Email Type')
        self.tree.column('Subject', width=250)
        self.tree.column('From', width=150)
        self.tree.column('Date', width=120)
        self.tree.column('Email Type', width=100)
        self.tree.grid(row=5, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Add scrollbar to treeview
        tree_scroll = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=self.tree.yview)
        tree_scroll.grid(row=5, column=3, sticky=(tk.N, tk.S))
        self.tree.configure(yscrollcommand=tree_scroll.set)
        
        # Email content area
        ttk.Label(main_frame, text="Email Content:").grid(row=6, column=0, sticky=tk.W, pady=5)
        
        self.content_text = scrolledtext.ScrolledText(main_frame, width=80, height=15)
        self.content_text.grid(row=7, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Extracted attributes area
        ttk.Label(main_frame, text="Extracted Attributes:").grid(row=6, column=2, sticky=tk.W, pady=5)
        
        self.attr_text = scrolledtext.ScrolledText(main_frame, width=40, height=15)
        self.attr_text.grid(row=7, column=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Bind selection event
        self.tree.bind('<<TreeviewSelect>>', self.on_email_select)
        
        # Store extracted data
        self.emails = []
        self.current_email_index = -1
        
    def browse_file(self):
        file_path = filedialog.askopenfilename(
            title="Select MSG File",
            filetypes=[("Outlook MSG Files", "*.msg"), ("All Files", "*.*")]
        )
        if file_path:
            self.file_path_var.set(file_path)
        
    def extract_email_chain(self):
        file_path = self.file_path_var.get().strip()
        
        if not file_path or not os.path.exists(file_path):
            messagebox.showwarning("Input Error", "Please select a valid MSG file")
            return
            
        self.progress.start()
        self.clear_results()
        
        try:
            # Process the MSG file
            self.emails = self.process_msg_file(file_path)
            
            # Display email chain in treeview
            for i, email_data in enumerate(self.emails):
                email_type = "Original"
                if i > 0:
                    email_type = f"Reply {i}" if "re:" in email_data['subject'].lower() else f"Forward {i}"
                
                self.tree.insert('', 'end', iid=str(i), values=(
                    email_data['subject'][:40] + "..." if len(email_data['subject']) > 40 else email_data['subject'],
                    email_data['sender'],
                    email_data['date'],
                    email_type
                ))
            
            if not self.emails:
                messagebox.showinfo("No Emails", "No emails found in the MSG file")
            else:
                messagebox.showinfo("Success", f"Found {len(self.emails)} emails in the chain")
                
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {str(e)}")
        finally:
            self.progress.stop()
            
    def process_msg_file(self, file_path):
        emails = []
        
        try:
            # Open the MSG file
            msg = extract_msg.Message(file_path)
            
            # Extract the main email
            main_email = self.extract_email_data(msg)
            if main_email:
                emails.append(main_email)
            
            # Check for embedded emails (replies/forwards in the body)
            body_emails = self.extract_emails_from_body(main_email['body'] if main_email else "")
            emails.extend(body_emails)
            
            # Check for attachments that might be emails
            if hasattr(msg, 'attachments'):
                for attachment in msg.attachments:
                    if attachment.type == 'msg':
                        try:
                            # Save attachment to temporary file
                            with tempfile.NamedTemporaryFile(suffix='.msg', delete=False) as temp_file:
                                temp_path = temp_file.name
                            
                            with open(temp_path, 'wb') as f:
                                f.write(attachment.data)
                            
                            # Recursively process the attached MSG file
                            attached_emails = self.process_msg_file(temp_path)
                            emails.extend(attached_emails)
                            
                            # Clean up
                            os.unlink(temp_path)
                            
                        except Exception as e:
                            print(f"Error processing attachment: {e}")
            
            # Close the message
            msg.close()
            
        except Exception as e:
            print(f"Error processing MSG file: {e}")
            
        return emails
    
    def extract_email_data(self, msg):
        try:
            subject = msg.subject or ""
            body = msg.body or ""
            html_body = msg.htmlBody or ""
            
            # Extract text content
            text_content = self.extract_text_content(body, html_body)
            
            # Get sender information
            sender = msg.sender or "Unknown"
            
            # Get date
            date = msg.date.strftime("%Y-%m-%d %H:%M:%S") if msg.date else "Unknown"
            
            # Store email data
            email_data = {
                'subject': subject,
                'sender': sender,
                'date': date,
                'body': text_content,
                'html_body': html_body
            }
            
            return email_data
            
        except Exception as e:
            print(f"Error extracting email data: {e}")
            return None
    
    def extract_emails_from_body(self, body):
        emails = []
        
        # Look for email separators and extract individual emails
        email_patterns = [
            r'From:.*?Subject:.*?Date:.*?(?=From:|Subject:|Date:|$)',
            r'-----Original Message-----.*?-----',
            r'On.*wrote:.*?From:.*?Subject:',
        ]
        
        for pattern in email_patterns:
            matches = re.finditer(pattern, body, re.DOTALL | re.IGNORECASE)
            for match in matches:
                email_text = match.group(0)
                
                # Extract email details from the text
                sender_match = re.search(r'From:\s*(.*?)(?=\n|$)', email_text, re.IGNORECASE)
                subject_match = re.search(r'Subject:\s*(.*?)(?=\n|$)', email_text, re.IGNORECASE)
                date_match = re.search(r'Date:\s*(.*?)(?=\n|$)', email_text, re.IGNORECASE)
                
                # Find the body content (after headers)
                body_start = max(
                    email_text.find('\n\n') if '\n\n' in email_text else 0,
                    email_text.find('\r\n\r\n') if '\r\n\r\n' in email_text else 0
                )
                
                email_body = email_text[body_start:].strip() if body_start > 0 else email_text
                
                email_data = {
                    'subject': subject_match.group(1) if subject_match else "No Subject",
                    'sender': sender_match.group(1) if sender_match else "Unknown",
                    'date': date_match.group(1) if date_match else "Unknown",
                    'body': email_body,
                    'html_body': ""
                }
                
                emails.append(email_data)
                
        return emails
    
    def extract_text_content(self, plain_text, html_content):
        if plain_text:
            return plain_text
        
        if html_content:
            try:
                # Use html2text to convert HTML to plain text
                h = html2text.HTML2Text()
                h.ignore_links = False
                return h.handle(html_content)
            except Exception as e:
                print(f"Error converting HTML to text: {e}")
                return html_content
                
        return ""
    
    def on_email_select(self, event):
        selection = self.tree.selection()
        if not selection:
            return
            
        email_index = int(selection[0])
        self.current_email_index = email_index
        
        if 0 <= email_index < len(self.emails):
            email_data = self.emails[email_index]
            
            # Display email content
            content = f"From: {email_data['sender']}\n"
            content += f"Date: {email_data['date']}\n"
            content += f"Subject: {email_data['subject']}\n"
            content += "-" * 50 + "\n"
            content += email_data['body']
            
            self.content_text.delete(1.0, tk.END)
            self.content_text.insert(1.0, content)
            
            # Clear attributes text
            self.attr_text.delete(1.0, tk.END)
    
    def extract_attributes(self):
        if self.current_email_index == -1 or not self.emails:
            messagebox.showwarning("No Selection", "Please select an email from the chain first")
            return
            
        email_data = self.emails[self.current_email_index]
        email_body = email_data['body']
        
        # Get attribute definitions
        attr_text = self.attribute_text.get(1.0, tk.END).strip()
        attribute_patterns = self.parse_attribute_definitions(attr_text)
        
        # Extract attributes
        attributes = self.extract_attributes_from_content(email_body, attribute_patterns)
        
        # Display attributes
        self.attr_text.delete(1.0, tk.END)
        if attributes:
            for attr, value in attributes:
                self.attr_text.insert(tk.END, f"{attr}: {value}\n")
        else:
            self.attr_text.insert(tk.END, "No attributes found in this email")
    
    def parse_attribute_definitions(self, attr_text):
        patterns = {}
        lines = attr_text.split('\n')
        
        for line in lines:
            line = line.strip()
            if line and ':' in line:
                parts = line.split(':', 1)
                if len(parts) == 2:
                    label = parts[0].strip()
                    pattern = parts[1].strip()
                    patterns[label] = pattern
                    
        return patterns
    
    def extract_attributes_from_content(self, content, attribute_patterns):
        attributes = []
        
        for label, pattern in attribute_patterns.items():
            try:
                # Try to find the pattern in the email content
                match = re.search(pattern, content, re.IGNORECASE)
                if match:
                    # If we have capturing groups, use the first one
                    if match.groups():
                        value = match.group(1).strip()
                    else:
                        value = match.group(0).strip()
                    
                    attributes.append((label, value))
                else:
                    # Try alternative patterns for common attributes
                    value = self.try_alternative_patterns(label, content)
                    if value:
                        attributes.append((label, value))
            except Exception as e:
                print(f"Error extracting {label}: {e}")
                
        return attributes
    
    def try_alternative_patterns(self, label, content):
        # Try alternative patterns for common attributes
        if label.lower() == 'trade id':
            # Look for patterns like TRADE123, ID: ABC123, etc.
            patterns = [
                r'TRADE\s*[#]?\s*([A-Z0-9-]+)',
                r'ID\s*[:\s]\s*([A-Z0-9-]+)',
                r'Transaction\s*[#]?\s*([A-Z0-9-]+)'
            ]
        elif label.lower() == 'date':
            patterns = [
                r'(\d{1,2}[/-]\d{1,2}[/-]\d{2,4})',
                r'Date\s*[:\s]\s*(\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{4})'
            ]
        elif label.lower() == 'quantity':
            patterns = [
                r'Qty\s*[:\s]\s*(\d+(?:\.\d+)?)',
                r'Quantity\s*[:\s]\s*(\d+(?:\.\d+)?)',
                r'(\d+(?:\.\d+)?)\s*(?:shares|units)'
            ]
        elif label.lower() == 'price':
            patterns = [
                r'Price\s*[:\s]\s*(\$?\d+(?:\.\d+)?)',
                r'@\s*(\$?\d+(?:\.\d+)?)',
                r'(\$?\d+(?:\.\d+)?)\s*per\s*(?:share|unit)'
            ]
        else:
            return None
            
        for pattern in patterns:
            match = re.search(pattern, content, re.IGNORECASE)
            if match:
                if match.groups():
                    return match.group(1).strip()
                else:
                    return match.group(0).strip()
                    
        return None
    
    def clear_results(self):
        self.tree.delete(*self.tree.get_children())
        self.content_text.delete(1.0, tk.END)
        self.attr_text.delete(1.0, tk.END)
        self.emails = []
        self.current_email_index = -1
    
    def export_to_csv(self):
        if not self.emails:
            messagebox.showwarning("No Data", "No emails to export")
            return
            
        try:
            # Get attribute definitions
            attr_text = self.attribute_text.get(1.0, tk.END).strip()
            attribute_patterns = self.parse_attribute_definitions(attr_text)
            
            # Create a DataFrame with all extracted data
            all_data = []
            for i, email_data in enumerate(self.emails):
                # Extract attributes for this email
                attributes = self.extract_attributes_from_content(email_data['body'], attribute_patterns)
                
                # Create a row for this email
                row_data = {
                    'Email_Index': i,
                    'Subject': email_data['subject'],
                    'From': email_data['sender'],
                    'Date': email_data['date'],
                    'Body_Preview': email_data['body'][:100] + "..." if len(email_data['body']) > 100 else email_data['body']
                }
                
                # Add extracted attributes
                for attr, value in attributes:
                    row_data[attr] = value
                
                all_data.append(row_data)
            
            df = pd.DataFrame(all_data)
            
            # Save to CSV
            filename = f"email_chain_export.csv"
            df.to_csv(filename, index=False)
            
            messagebox.showinfo("Success", f"Data exported to {filename}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export data: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    app = EmailChainExtractor(root)
    root.mainloop()
