import re
import locale
import time
from datetime import datetime, timedelta

def extract_email_chain_from_outlook(self):
    trade_ids_str = None
    df = pd.DataFrame(columns=self.selected_columns)
    if hasattr(self, "trade_ids_var") or isinstance(self.trade_ids_var, tk.StringVar):
        trade_ids_str = self.trade_ids_var.get().strip()
    if not trade_ids_str:
        file_path = self.file_path_var.get().strip()
        if not file_path or not os.path.exists(file_path):
            messagebox.showwarning("Input Error", "Please upload a valid file/input trade_id")
            return
        self.trade_ids_var.set(self.process_trade_file(file_path))
        trade_ids_str = self.trade_ids_var.get().strip()

    trade_ids = [tid.strip() for tid in re.split(",|\\s", trade_ids_str) if tid.strip()]
    folder = self.connect_to_outlook()
    if not folder:
        return

    self.progress.start()
    self.clear_results()
    self.emails = []
    self.unfound_trades = []

    try:
        # --- Date & Regional Format Detection ---
        today = datetime.now()
        days_back = 12
        date_limit = today - timedelta(days=days_back)

        # Auto-detect system date format
        # Fallback logic covers most Windows/Outlook setups
        sys_format = None
        fmt_example = time.strftime('%x')
        sep = None
        if len(fmt_example) > 2 and fmt_example[2] in ['/', '-', '.']:
            sep = fmt_example[2]
            if sep == '/':
                sys_format = (
                    '%m/%d/%Y' if today.strftime('%x').split('/')[0] == today.strftime('%m')
                    else '%d/%m/%Y'
                )
            elif sep == '-':
                sys_format = '%Y-%m-%d'
            else:
                sys_format = '%d.%m.%Y'
        if not sys_format:
            sys_format = '%m/%d/%Y'   # Fallback US

        print(f"Detected date format for Restrict: {sys_format}")

        date_str = date_limit.strftime(sys_format)

        # --- Regex for all Trade IDs ---
        pattern = re.compile("|".join(re.escape(tid) for tid in trade_ids))

        # --- Outlook Restrict: Try upper and lower AM/PM ---
        items_list = []
        got_data = False
        for ampm_case in [('AM', 'PM'), ('am', 'pm')]:
            start = f"{date_str} 12:00:00 {ampm_case[0]}"
            end = f"{date_str} 11:59:59 {ampm_case[1]}"
            filter_str = f"[ReceivedTime] >= '{start}' AND [ReceivedTime] <= '{end}'"
            print(f"Trying filter: {filter_str}")
            items = folder.Items.Restrict(filter_str)
            items_list = list(items)
            if len(items_list) > 0:
                got_data = True
                print(f"Found {len(items_list)} items with {ampm_case}.")
                break

        if not got_
            print("No emails found, consider alternate/fallback querying!")
            # Optionally: Try a wide 'no AM/PM' or 24-hour query

        # --- Main Body/Subject Search ---
        for item in items_list:
            if item.Class == 43:
                subject = item.Subject or ""
                sender = getattr(item, "SenderName", "")
                recipient = getattr(item, "To", "")
                date_val = item.ReceivedTime.strftime("%Y-%m-%d %H:%M:%S")
                if pattern.search(subject):
                    matched_tid = pattern.findall(subject)
                else:
                    body = item.Body or ""
                    html_body = ""
                    try:
                        html_body = item.HTMLBody
                    except:
                        pass
                    all_text = body + ("\n" + html_body if html_body else "")
                    if not pattern.search(all_text):
                        continue
                    matched_tid = pattern.findall(all_text)

                for tid in set(matched_tid):
                    self.emails.append({
                        'trade_id': tid,
                        'subject': subject[:60] + "..." if len(subject) > 60 else subject,
                        'sender': sender[:20],
                        'recipient': recipient[:20],
                        'date': date_val,
                        'body': item.Body,
                        'email_type': "Original",
                    })

        found_trade_ids = set(mail['trade_id'] for mail in self.emails)
        self.unfound_trades = [tid for tid in trade_ids if tid not in found_trade_ids]

        for idx, mail in enumerate(self.emails):
            email_type = "Original"
            subj = mail['subject'].lower()
            if "re:" in subj:
                email_type = f"Reply {idx}"
            elif "fw:" in subj or "fwd:" in subj:
                email_type = f"Forward {idx}"
            else:
                email_type = f"Email {idx}"
            self.tree.insert(
                '', 'end', iid=str(idx),
                values=(
                    mail['trade_id'],
                    mail['subject'],
                    mail['sender'],
                    mail['recipient'],
                    mail['date'],
                    email_type
                )
            )

        messagebox.showinfo("Success", f"Loaded {len(self.emails)} emails across {len(trade_ids)} Trade IDs.")

    except Exception as e:
        messagebox.showerror("Extraction Error", f"Failed to extract emails: {e}")
    finally:
        self.progress.stop()
