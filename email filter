import re
import time
from datetime import datetime, timedelta

def get_system_datetime_format_and_ampm():
    """Get system's regional date format and AM/PM casing exactly as used in system settings."""
    dt = datetime(2025, 10, 9, 13, 1, 1)
    # Short date: e.g. 09/10/2025, 10/09/2025, 2025-10-09 etc.
    raw_date = dt.strftime('%x')
    # Am/Pm
    am_str = dt.replace(hour=1).strftime('%p')  # 'AM'/'am'
    pm_str = dt.replace(hour=13).strftime('%p') # 'PM'/'pm'

    # Guess date format from separator and order
    if '/' in raw_date:
        parts = raw_date.split('/')
        if int(parts[0]) > 12:
            date_fmt = '%d/%m/%Y'
        elif int(parts[1]) > 12:
            date_fmt = '%m/%d/%Y'
        else:
            date_fmt = '%m/%d/%Y'
    elif '-' in raw_date:
        parts = raw_date.split('-')
        if len(parts[0]) == 4:
            date_fmt = '%Y-%m-%d'
        else:
            date_fmt = '%d-%m-%Y'
    elif '.' in raw_date:
        parts = raw_date.split('.')
        if len(parts[0]) == 4:
            date_fmt = '%Y.%m.%d'
        else:
            date_fmt = '%d.%m.%Y'
    else:
        date_fmt = '%m/%d/%Y'

    return date_fmt, am_str, pm_str

def extract_email_chain_from_outlook(self):
    trade_ids_str = None
    df = pd.DataFrame(columns=self.selected_columns)
    if hasattr(self, "trade_ids_var") or isinstance(self.trade_ids_var, tk.StringVar):
        trade_ids_str = self.trade_ids_var.get().strip()
    if not trade_ids_str:
        file_path = self.file_path_var.get().strip()
        if not file_path or not os.path.exists(file_path):
            messagebox.showwarning("Input Error", "Please upload a valid file/input trade_id")
            return
        self.trade_ids_var.set(self.process_trade_file(file_path))
        trade_ids_str = self.trade_ids_var.get().strip()

    trade_ids = [tid.strip() for tid in re.split(",|\\s", trade_ids_str) if tid.strip()]
    folder = self.connect_to_outlook()
    if not folder:
        return

    self.progress.start()
    self.clear_results()
    self.emails = []
    self.unfound_trades = []

    try:
        today = datetime.now()
        days_back = 2    # Edit as needed
        
        # --- Regional Format (date and am/pm) Detection ---
        date_fmt, am_marker, pm_marker = get_system_datetime_format_and_ampm()
        print(f"Date format: {date_fmt}, AM/PM: {am_marker}/{pm_marker}")

        # --- Compile regex pattern for all trade IDs
        pattern = re.compile("|".join(re.escape(tid) for tid in trade_ids))

        all_items = []
        for days_ago in range(1, days_back + 1):
            the_date = today - timedelta(days=days_ago)
            date_str = the_date.strftime(date_fmt)
            start = f"{date_str} 12:00:00 {am_marker}"
            end = f"{date_str} 11:59:59 {pm_marker}"
            filter_str = f"[ReceivedTime] >= '{start}' AND [ReceivedTime] <= '{end}'"
            print(f"Outlook Restrict filter: {filter_str}")
            items = folder.Items.Restrict(filter_str)
            items_list = list(items)
            if not items_list and am_marker.isupper():
                # Fallback: try lowercase
                start = f"{date_str} 12:00:00 {am_marker.lower()}"
                end = f"{date_str} 11:59:59 {pm_marker.lower()}"
                filter_str = f"[ReceivedTime] >= '{start}' AND [ReceivedTime] <= '{end}'"
                items = folder.Items.Restrict(filter_str)
                items_list = list(items)
            elif not items_list and am_marker.islower():
                # Fallback: try uppercase
                start = f"{date_str} 12:00:00 {am_marker.upper()}"
                end = f"{date_str} 11:59:59 {pm_marker.upper()}"
                filter_str = f"[ReceivedTime] >= '{start}' AND [ReceivedTime] <= '{end}'"
                items = folder.Items.Restrict(filter_str)
                items_list = list(items)

            if items_list:
                print(f"Found {len(items_list)} items for {date_str}")
                all_items.extend(items_list)
            else:
                print(f"No emails found for {date_str}")

        for item in all_items:
            if item.Class == 43:
                subject = item.Subject or ""
                sender = getattr(item, "SenderName", "")
                recipient = getattr(item, "To", "")
                date_val = item.ReceivedTime.strftime("%Y-%m-%d %H:%M:%S")
                if pattern.search(subject):
                    matched_tid = pattern.findall(subject)
                else:
                    body = item.Body or ""
                    html_body = ""
                    try:
                        html_body = item.HTMLBody
                    except:
                        pass
                    all_text = body + ("\n" + html_body if html_body else "")
                    if not pattern.search(all_text):
                        continue
                    matched_tid = pattern.findall(all_text)

                for tid in set(matched_tid):
                    self.emails.append({
                        'trade_id': tid,
                        'subject': subject[:60] + "..." if len(subject) > 60 else subject,
                        'sender': sender[:20],
                        'recipient': recipient[:20],
                        'date': date_val,
                        'body': item.Body,
                        'email_type': "Original",
                    })

        found_trade_ids = set(mail['trade_id'] for mail in self.emails)
        self.unfound_trades = [tid for tid in trade_ids if tid not in found_trade_ids]

        for idx, mail in enumerate(self.emails):
            email_type = "Original"
            subj = mail['subject'].lower()
            if "re:" in subj:
                email_type = f"Reply {idx}"
            elif "fw:" in subj or "fwd:" in subj:
                email_type = f"Forward {idx}"
            else:
                email_type = f"Email {idx}"
            self.tree.insert(
                '', 'end', iid=str(idx),
                values=(
                    mail['trade_id'],
                    mail['subject'],
                    mail['sender'],
                    mail['recipient'],
                    mail['date'],
                    email_type
                )
            )

        messagebox.showinfo("Success", f"Loaded {len(self.emails)} emails across {len(trade_ids)} Trade IDs.")

    except Exception as e:
        messagebox.showerror("Extraction Error", f"Failed to extract emails: {e}")
    finally:
        self.progress.stop()
