import re
import time
from datetime import datetime, timedelta

def get_locale_outlook_fmt():
    """Detect date format and 12/24hr mode and return (date_fmt, time_fmt, use_ampm)"""
    dt = datetime(2025, 10, 9, 17, 36, 0)
    # Sample: date string '09-10-2025' and time string '17:36:00'
    raw_date = dt.strftime('%x')
    raw_time = dt.strftime('%X')
    # AM/PM detection
    ampm = dt.replace(hour=1).strftime('%p')
    is_12h = ('AM' in ampm) or ('PM' in ampm) or ('am' in ampm) or ('pm' in ampm)

    # Date format guess from separator and order
    if '/' in raw_date:
        parts = raw_date.split('/')
        if int(parts[0]) > 12:
            date_fmt = '%d/%m/%Y'
        elif int(parts[1]) > 12:
            date_fmt = '%m/%d/%Y'
        else:
            date_fmt = '%m/%d/%Y'
        sep = '/'
    elif '-' in raw_date:
        parts = raw_date.split('-')
        if len(parts[0]) == 4:
            date_fmt = '%Y-%m-%d'
        else:
            date_fmt = '%d-%m-%Y'
        sep = '-'
    elif '.' in raw_date:
        parts = raw_date.split('.')
        if len(parts[0]) == 4:
            date_fmt = '%Y.%m.%d'
        else:
            date_fmt = '%d.%m.%Y'
        sep = '.'
    else:
        date_fmt = '%m/%d/%Y'
        sep = '/'

    # Time format: either 24h or 12h with AM/PM (case)
    if is_12h:
        # Check if AM/PM in lower or upper
        am = dt.replace(hour=1).strftime('%p')
        pm = dt.replace(hour=13).strftime('%p')
        time_fmt = '%I:%M:%S'
        use_ampm = True
        # pass through AM/PM style
        return date_fmt, time_fmt, am, pm, sep, use_ampm
    else:
        time_fmt = '%H:%M:%S'
        use_ampm = False
        return date_fmt, time_fmt, '', '', sep, use_ampm

# In your extraction code
def extract_email_chain_from_outlook(self):
    trade_ids_str = None
    df = pd.DataFrame(columns=self.selected_columns)
    if hasattr(self, "trade_ids_var") or isinstance(self.trade_ids_var, tk.StringVar):
        trade_ids_str = self.trade_ids_var.get().strip()
    if not trade_ids_str:
        file_path = self.file_path_var.get().strip()
        if not file_path or not os.path.exists(file_path):
            messagebox.showwarning("Input Error", "Please upload a valid file/input trade_id")
            return
        self.trade_ids_var.set(self.process_trade_file(file_path))
        trade_ids_str = self.trade_ids_var.get().strip()

    trade_ids = [tid.strip() for tid in re.split(",|\\s", trade_ids_str) if tid.strip()]
    folder = self.connect_to_outlook()
    if not folder:
        return

    self.progress.start()
    self.clear_results()
    self.emails = []
    self.unfound_trades = []

    try:
        today = datetime.now()
        days_back = 2    # Or as needed
        
        # --- Detect locale-aware restrict formats ---
        date_fmt, time_fmt, am, pm, sep, use_ampm = get_locale_outlook_fmt()
        print(f"Locale restrict format: {date_fmt} {time_fmt} AM/PM:{am}/{pm} use_ampm:{use_ampm}")

        pattern = re.compile("|".join(re.escape(tid) for tid in trade_ids))
        all_items = []
        for days_ago in range(1, days_back + 1):
            the_date = today - timedelta(days=days_ago)
            date_str = the_date.strftime(date_fmt)
            start_time = f"{date_str} 00:00:00"
            end_time   = f"{date_str} 23:59:59"
            if use_ampm:
                start_time = f"{date_str} 12:00:00 {am}"
                end_time   = f"{date_str} 11:59:59 {pm}"

            filter_str = f"[ReceivedTime] >= '{start_time}' AND [ReceivedTime] <= '{end_time}'"
            print("Trying Restrict filter:", filter_str)
            items = folder.Items.Restrict(filter_str)
            items_list = list(items)
            if not items_list and use_ampm:
                # Fallback: try other case for AM/PM
                start_time_lower = f"{date_str} 12:00:00 {am.lower()}"
                end_time_lower   = f"{date_str} 11:59:59 {pm.lower()}"
                filter_str = f"[ReceivedTime] >= '{start_time_lower}' AND [ReceivedTime] <= '{end_time_lower}'"
                items = folder.Items.Restrict(filter_str)
                items_list = list(items)
            if items_list:
                print(f"Restrict: {len(items_list)} found for {date_str}")
                all_items.extend(items_list)
            else:
                print(f"No emails: {date_str}")

        for item in all_items:
            if item.Class == 43:
                subject = item.Subject or ""
                sender = getattr(item, "SenderName", "")
                recipient = getattr(item, "To", "")
                date_val = item.ReceivedTime.strftime("%Y-%m-%d %H:%M:%S")
                if pattern.search(subject):
                    matched_tid = pattern.findall(subject)
                else:
                    body = item.Body or ""
                    html_body = ""
                    try:
                        html_body = item.HTMLBody
                    except:
                        pass
                    all_text = body + ("\n" + html_body if html_body else "")
                    if not pattern.search(all_text):
                        continue
                    matched_tid = pattern.findall(all_text)

                for tid in set(matched_tid):
                    self.emails.append({
                        'trade_id': tid,
                        'subject': subject[:60] + "..." if len(subject) > 60 else subject,
                        'sender': sender[:20],
                        'recipient': recipient[:20],
                        'date': date_val,
                        'body': item.Body,
                        'email_type': "Original",
                    })

        found_trade_ids = set(mail['trade_id'] for mail in self.emails)
        self.unfound_trades = [tid for tid in trade_ids if tid not in found_trade_ids]

        for idx, mail in enumerate(self.emails):
            email_type = "Original"
            subj = mail['subject'].lower()
            if "re:" in subj:
                email_type = f"Reply {idx}"
            elif "fw:" in subj or "fwd:" in subj:
                email_type = f"Forward {idx}"
            else:
                email_type = f"Email {idx}"
            self.tree.insert(
                '', 'end', iid=str(idx),
                values=(
                    mail['trade_id'],
                    mail['subject'],
                    mail['sender'],
                    mail['recipient'],
                    mail['date'],
                    email_type
                )
            )

        messagebox.showinfo("Success", f"Loaded {len(self.emails)} emails across {len(trade_ids)} Trade IDs.")

    except Exception as e:
        messagebox.showerror("Extraction Error", f"Failed to extract emails: {e}")
    finally:
        self.progress.stop()
