import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import win32com.client
import pandas as pd
from bs4 import BeautifulSoup
import os
import re
import tempfile
import pythoncom

class MSGEmailExtractor:
    def __init__(self, root):
        self.root = root
        self.root.title("Outlook MSG File Extractor by Trade ID")
        self.root.geometry("900x700")
        self.root.resizable(True, True)
        
        # Configure style
        style = ttk.Style()
        style.theme_use('clam')
        
        # Create main frame
        main_frame = ttk.Frame(root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        root.columnconfigure(0, weight=1)
        root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(5, weight=1)
        
        # File selection
        ttk.Label(main_frame, text="MSG File:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.file_path_var = tk.StringVar()
        file_entry = ttk.Entry(main_frame, textvariable=self.file_path_var, width=50)
        file_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=5, padx=(0, 5))
        ttk.Button(main_frame, text="Browse", command=self.browse_file).grid(row=0, column=2, pady=5)
        
        # Trade ID input
        ttk.Label(main_frame, text="Trade ID:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.trade_id_var = tk.StringVar()
        trade_id_entry = ttk.Entry(main_frame, textvariable=self.trade_id_var, width=30)
        trade_id_entry.grid(row=1, column=1, sticky=(tk.W, tk.E), pady=5)
        
        # Buttons frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=2, column=0, columnspan=3, pady=10)
        
        ttk.Button(button_frame, text="Extract Emails", command=self.extract_emails).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Clear Results", command=self.clear_results).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Export to CSV", command=self.export_to_csv).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Export Tables", command=self.export_tables).pack(side=tk.LEFT, padx=5)
        
        # Progress bar
        self.progress = ttk.Progressbar(main_frame, mode='indeterminate')
        self.progress.grid(row=3, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=5)
        
        # Results area
        ttk.Label(main_frame, text="Extracted Emails:").grid(row=4, column=0, sticky=tk.W, pady=5)
        
        # Treeview for email list
        self.tree = ttk.Treeview(main_frame, columns=('Subject', 'From', 'Date', 'Trade ID'), show='headings')
        self.tree.heading('Subject', text='Subject')
        self.tree.heading('From', text='From')
        self.tree.heading('Date', text='Date')
        self.tree.heading('Trade ID', text='Trade ID')
        self.tree.column('Subject', width=250)
        self.tree.column('From', width=150)
        self.tree.column('Date', width=120)
        self.tree.column('Trade ID', width=100)
        self.tree.grid(row=5, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Add scrollbar to treeview
        tree_scroll = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=self.tree.yview)
        tree_scroll.grid(row=5, column=3, sticky=(tk.N, tk.S))
        self.tree.configure(yscrollcommand=tree_scroll.set)
        
        # Email content area
        ttk.Label(main_frame, text="Email Content:").grid(row=6, column=0, sticky=tk.W, pady=5)
        
        self.content_text = scrolledtext.ScrolledText(main_frame, width=80, height=15)
        self.content_text.grid(row=7, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Bind selection event
        self.tree.bind('<<TreeviewSelect>>', self.on_email_select)
        
        # Store extracted emails
        self.emails = []
        
    def browse_file(self):
        file_path = filedialog.askopenfilename(
            title="Select MSG File",
            filetypes=[("Outlook MSG Files", "*.msg"), ("All Files", "*.*")]
        )
        if file_path:
            self.file_path_var.set(file_path)
        
    def extract_emails(self):
        file_path = self.file_path_var.get().strip()
        trade_id = self.trade_id_var.get().strip()
        
        if not file_path or not os.path.exists(file_path):
            messagebox.showwarning("Input Error", "Please select a valid MSG file")
            return
            
        if not trade_id:
            messagebox.showwarning("Input Error", "Please enter a Trade ID")
            return
            
        self.progress.start()
        self.clear_results()
        
        try:
            # Initialize COM for this thread
            pythoncom.CoInitialize()
            
            # Open the MSG file
            outlook = win32com.client.Dispatch("Outlook.Application")
            msg = outlook.Session.OpenSharedItem(file_path)
            
            # Extract emails from the MSG file
            found_emails = self.process_msg_item(msg, trade_id)
            
            # Store emails
            self.emails = found_emails
            
            # Add to treeview
            for email in found_emails:
                self.tree.insert('', 'end', values=(
                    email['subject'][:40] + "..." if len(email['subject']) > 40 else email['subject'],
                    email['sender'],
                    email['date'],
                    trade_id
                ))
            
            if not found_emails:
                messagebox.showinfo("No Results", f"No emails found with Trade ID: {trade_id}")
            else:
                messagebox.showinfo("Success", f"Found {len(found_emails)} emails with Trade ID: {trade_id}")
                
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {str(e)}")
        finally:
            self.progress.stop()
            # Uninitialize COM
            try:
                pythoncom.CoUninitialize()
            except:
                pass
            
    def process_msg_item(self, msg_item, trade_id):
        emails = []
        
        # Check if this is an email
        if hasattr(msg_item, 'Class') and msg_item.Class == 43:  # MailItem
            subject = msg_item.Subject or ""
            body = msg_item.Body or ""
            html_body = msg_item.HTMLBody or ""
            
            # Check if trade ID is in subject, body, or HTML body
            if (trade_id in subject or 
                trade_id in body or 
                (html_body and trade_id in html_body)):
                
                # Extract tables from HTML body if available
                tables = []
                if html_body:
                    tables = self.extract_tables_from_html(html_body)
                    
                # Extract text content
                text_content = self.extract_text_content(body, html_body)
                
                # Get sender information
                sender = "Unknown"
                if hasattr(msg_item, 'SenderName'):
                    sender = msg_item.SenderName
                elif hasattr(msg_item, 'SenderEmailAddress'):
                    sender = msg_item.SenderEmailAddress
                
                # Get date
                date = "Unknown"
                if hasattr(msg_item, 'ReceivedTime'):
                    date = msg_item.ReceivedTime.strftime("%Y-%m-%d %H:%M:%S")
                
                # Store email data
                email_data = {
                    'subject': subject,
                    'sender': sender,
                    'date': date,
                    'trade_id': trade_id,
                    'body': text_content,
                    'tables': tables,
                    'html_body': html_body
                }
                
                emails.append(email_data)
        
        # Check for attachments that might be emails
        if hasattr(msg_item, 'Attachments'):
            for attachment in msg_item.Attachments:
                try:
                    # Save attachment to temporary file
                    with tempfile.NamedTemporaryFile(suffix='.msg', delete=False) as temp_file:
                        temp_path = temp_file.name
                    
                    attachment.SaveAsFile(temp_path)
                    
                    # Open the attachment as MSG file
                    outlook = win32com.client.Dispatch("Outlook.Application")
                    attached_msg = outlook.Session.OpenSharedItem(temp_path)
                    
                    # Recursively process the attached MSG file
                    emails.extend(self.process_msg_item(attached_msg, trade_id))
                    
                    # Clean up
                    os.unlink(temp_path)
                    
                except Exception as e:
                    print(f"Error processing attachment: {e}")
        
        return emails
    
    def extract_tables_from_html(self, html_content):
        tables = []
        try:
            soup = BeautifulSoup(html_content, 'html.parser')
            for table in soup.find_all('table'):
                # Extract table data
                table_data = []
                for row in table.find_all('tr'):
                    cols = row.find_all(['td', 'th'])
                    cols = [col.text.strip() for col in cols]
                    if cols:
                        table_data.append(cols)
                
                if table_data:
                    tables.append(table_data)
        except Exception as e:
            print(f"Error extracting tables: {e}")
        return tables
    
    def extract_text_content(self, plain_text, html_content):
        if plain_text:
            return plain_text
        
        if html_content:
            try:
                soup = BeautifulSoup(html_content, 'html.parser')
                return soup.get_text(separator='\n')
            except:
                return html_content
                
        return ""
    
    def on_email_select(self, event):
        selection = self.tree.selection()
        if not selection:
            return
            
        item = self.tree.item(selection[0])
        subject = item['values'][0]
        
        # Find the selected email in our stored data
        selected_email = None
        for email in self.emails:
            if email['subject'].startswith(subject.replace("...", "")):
                selected_email = email
                break
                
        if selected_email:
            # Display email content
            content = f"From: {selected_email['sender']}\n"
            content += f"Date: {selected_email['date']}\n"
            content += f"Subject: {selected_email['subject']}\n"
            content += f"Trade ID: {selected_email['trade_id']}\n"
            content += "-" * 50 + "\n"
            content += selected_email['body']
            
            # Add table information
            if selected_email['tables']:
                content += f"\n\nFound {len(selected_email['tables'])} table(s) in this email."
                
            self.content_text.delete(1.0, tk.END)
            self.content_text.insert(1.0, content)
    
    def clear_results(self):
        self.tree.delete(*self.tree.get_children())
        self.content_text.delete(1.0, tk.END)
        self.emails = []
    
    def export_to_csv(self):
        if not self.emails:
            messagebox.showwarning("No Data", "No emails to export")
            return
            
        try:
            # Create a DataFrame from the extracted emails
            data = []
            for email in self.emails:
                # Flatten tables into a string representation
                tables_str = ""
                for i, table in enumerate(email['tables']):
                    tables_str += f"Table {i+1}: {len(table)} rows, {len(table[0]) if table else 0} columns; "
                
                data.append({
                    'Subject': email['subject'],
                    'From': email['sender'],
                    'Date': email['date'],
                    'Trade ID': email['trade_id'],
                    'Body Preview': email['body'][:100] + "..." if len(email['body']) > 100 else email['body'],
                    'Tables': tables_str
                })
            
            df = pd.DataFrame(data)
            
            # Save to CSV
            filename = f"trade_emails_{self.trade_id_var.get()}.csv"
            df.to_csv(filename, index=False)
            
            messagebox.showinfo("Success", f"Data exported to {filename}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export data: {str(e)}")
    
    def export_tables(self):
        if not self.emails:
            messagebox.showwarning("No Data", "No emails to export tables from")
            return
            
        try:
            # Create directory for tables
            os.makedirs("extracted_tables", exist_ok=True)
            
            table_count = 0
            for i, email in enumerate(self.emails):
                if email['tables']:
                    for j, table in enumerate(email['tables']):
                        try:
                            # Create DataFrame from table data
                            df = pd.DataFrame(table[1:], columns=table[0])
                            
                            # Save to CSV
                            filename = f"extracted_tables/email_{i+1}_table_{j+1}.csv"
                            df.to_csv(filename, index=False)
                            table_count += 1
                        except Exception as e:
                            print(f"Error exporting table: {e}")
            
            messagebox.showinfo("Success", f"Exported {table_count} tables to 'extracted_tables' folder")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export tables: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    app = MSGEmailExtractor(root)
    root.mainloop()
