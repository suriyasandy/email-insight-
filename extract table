from bs4 import BeautifulSoup
import csv
from tkinter import Toplevel, Scrollbar, Listbox, RIGHT, LEFT, BOTH, Y

def extract_tables(self):
    if not self.emails:
        messagebox.showwarning("No Data", "No emails loaded for extraction")
        return
    
    all_tables = []  # Will hold extracted data from all emails
    
    for idx, email in enumerate(self.emails):
        html_content = email.get('html_body', '')
        if not html_content:
            continue
        
        soup = BeautifulSoup(html_content, 'html.parser')
        tables = soup.find_all('table')
        
        for table in tables:
            headers = []
            rows = []
            # Extract headers if any
            header_row = table.find('tr')
            if header_row:
                headers = [th.get_text(strip=True) for th in header_row.find_all('th')]
            # Extract all rows
            for tr in table.find_all('tr')[1:]:  # Skip header row
                cols = tr.find_all(['td','th'])
                row_data = [col.get_text(strip=True) for col in cols]
                rows.append(row_data)
            
            # Store table data with email context
            all_tables.append({
                'email_index': idx,
                'subject': email.get('subject', ''),
                'headers': headers,
                'rows': rows
            })
    
    if not all_tables:
        messagebox.showinfo("No Tables", "No HTML tables found in email chain")
        return

    # Optionally show extracted tables in popup window (optional)
    self.show_tables_popup(all_tables)
    
    # Export combined tables to CSV
    self.export_tables_to_csv(all_tables)

def show_tables_popup(self, all_tables):
    popup = Toplevel(self.root)
    popup.title("Extracted HTML Tables")
    listbox = Listbox(popup, width=120, height=30)
    scrollbar = Scrollbar(popup)
    scrollbar.pack(side=RIGHT, fill=Y)
    listbox.pack(side=LEFT, fill=BOTH, expand=True)
    listbox.config(yscrollcommand=scrollbar.set)
    scrollbar.config(command=listbox.yview)

    for table_info in all_tables:
        listbox.insert('end', f"Email #{table_info['email_index']} Subject: {table_info['subject']}")
        if table_info['headers']:
            listbox.insert('end', "\t".join(table_info['headers']))
        for row in table_info['rows']:
            listbox.insert('end', "\t".join(row))
        listbox.insert('end', "-"*80)

def export_tables_to_csv(self, all_tables):
    filename = filedialog.asksaveasfilename(
        title="Save Extracted Tables CSV",
        defaultextension=".csv",
        filetypes=[("CSV Files", "*.csv"), ("All Files", "*.*")]
    )
    if not filename:
        return
    try:
        with open(filename, mode='w', newline='', encoding='utf-8') as csv_file:
            writer = csv.writer(csv_file)
            for table_info in all_tables:
                writer.writerow([f"Email Index: {table_info['email_index']}", f"Subject: {table_info['subject']}"])
                if table_info['headers']:
                    writer.writerow(table_info['headers'])
                for row in table_info['rows']:
                    writer.writerow(row)
                writer.writerow([])  # Blank line between tables
        messagebox.showinfo("Export Success", f"Extracted tables exported to {filename}")
    except Exception as e:
        messagebox.showerror("Export Error", f"Failed to export CSV: {e}")

ttk.Button(button_frame, text="Extract Tables", command=self.extract_tables).pack(side=tk.LEFT, padx=5)
