import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import win32com.client
import pandas as pd
from bs4 import BeautifulSoup
import re
import os

class OutlookEmailExtractor:
    def __init__(self, root):
        self.root = root
        self.root.title("Outlook Email Extractor by Trade ID")
        self.root.geometry("900x700")
        self.root.resizable(True, True)
        
        # Configure style
        style = ttk.Style()
        style.theme_use('clam')
        
        # Create main frame
        main_frame = ttk.Frame(root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        root.columnconfigure(0, weight=1)
        root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(5, weight=1)
        
        # Trade ID input
        ttk.Label(main_frame, text="Trade ID:").grid(row=0, column=0, sticky=tk.W, pady=5)
        self.trade_id_var = tk.StringVar()
        trade_id_entry = ttk.Entry(main_frame, textvariable=self.trade_id_var, width=30)
        trade_id_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), pady=5)
        
        # Folder selection
        ttk.Label(main_frame, text="Outlook Folder:").grid(row=1, column=0, sticky=tk.W, pady=5)
        self.folder_var = tk.StringVar(value="Inbox")
        folder_combo = ttk.Combobox(main_frame, textvariable=self.folder_var, 
                                   values=["Inbox", "Sent Items", "Drafts", "Archive"])
        folder_combo.grid(row=1, column=1, sticky=(tk.W, tk.E), pady=5)
        
        # Buttons frame
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=2, column=0, columnspan=2, pady=10)
        
        ttk.Button(button_frame, text="Extract Emails", command=self.extract_emails).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Clear Results", command=self.clear_results).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Export to CSV", command=self.export_to_csv).pack(side=tk.LEFT, padx=5)
        
        # Progress bar
        self.progress = ttk.Progressbar(main_frame, mode='indeterminate')
        self.progress.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=5)
        
        # Results area
        ttk.Label(main_frame, text="Extracted Emails:").grid(row=4, column=0, sticky=tk.W, pady=5)
        
        # Treeview for email list
        self.tree = ttk.Treeview(main_frame, columns=('Subject', 'From', 'Date', 'Trade ID'), show='headings')
        self.tree.heading('Subject', text='Subject')
        self.tree.heading('From', text='From')
        self.tree.heading('Date', text='Date')
        self.tree.heading('Trade ID', text='Trade ID')
        self.tree.column('Subject', width=250)
        self.tree.column('From', width=150)
        self.tree.column('Date', width=120)
        self.tree.column('Trade ID', width=100)
        self.tree.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Add scrollbar to treeview
        tree_scroll = ttk.Scrollbar(main_frame, orient=tk.VERTICAL, command=self.tree.yview)
        tree_scroll.grid(row=5, column=2, sticky=(tk.N, tk.S))
        self.tree.configure(yscrollcommand=tree_scroll.set)
        
        # Email content area
        ttk.Label(main_frame, text="Email Content:").grid(row=6, column=0, sticky=tk.W, pady=5)
        
        self.content_text = scrolledtext.ScrolledText(main_frame, width=80, height=15)
        self.content_text.grid(row=7, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        
        # Bind selection event
        self.tree.bind('<<TreeviewSelect>>', self.on_email_select)
        
        # Store extracted emails
        self.emails = []
        
    def connect_to_outlook(self):
        try:
            outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
            folder_name = self.folder_var.get()
            
            if folder_name == "Inbox":
                folder = outlook.GetDefaultFolder(6)  # Inbox
            elif folder_name == "Sent Items":
                folder = outlook.GetDefaultFolder(5)  # Sent Items
            elif folder_name == "Drafts":
                folder = outlook.GetDefaultFolder(16)  # Drafts
            elif folder_name == "Archive":
                folder = outlook.GetDefaultFolder(4)  # Archive
            else:
                folder = outlook.GetDefaultFolder(6)  # Default to Inbox
                
            return folder
        except Exception as e:
            messagebox.showerror("Error", f"Could not connect to Outlook: {str(e)}")
            return None
        
    def extract_emails(self):
        trade_id = self.trade_id_var.get().strip()
        if not trade_id:
            messagebox.showwarning("Input Error", "Please enter a Trade ID")
            return
            
        folder = self.connect_to_outlook()
        if not folder:
            return
            
        self.progress.start()
        self.clear_results()
        
        try:
            # Get all items in the folder
            items = folder.Items
            items.Sort("[ReceivedTime]", True)
            
            # Search for emails with the Trade ID
            found_emails = []
            for item in items:
                if item.Class == 43:  # MailItem
                    # Check subject and body for trade ID
                    subject = item.Subject or ""
                    body = item.Body or ""
                    html_body = item.HTMLBody or ""
                    
                    # Check if trade ID is in subject, body, or HTML body
                    if (trade_id in subject or 
                        trade_id in body or 
                        (html_body and trade_id in html_body)):
                        
                        # Extract tables from HTML body if available
                        tables = []
                        if html_body:
                            tables = self.extract_tables_from_html(html_body)
                            
                        # Extract text content
                        text_content = self.extract_text_content(body, html_body)
                        
                        # Store email data
                        email_data = {
                            'subject': subject,
                            'sender': item.SenderName,
                            'date': item.ReceivedTime.strftime("%Y-%m-%d %H:%M:%S") if item.ReceivedTime else "",
                            'trade_id': trade_id,
                            'body': text_content,
                            'tables': tables,
                            'html_body': html_body
                        }
                        
                        found_emails.append(email_data)
                        
                        # Add to treeview
                        self.tree.insert('', 'end', values=(
                            subject[:40] + "..." if len(subject) > 40 else subject,
                            item.SenderName,
                            email_data['date'],
                            trade_id
                        ))
            
            self.emails = found_emails
            
            if not found_emails:
                messagebox.showinfo("No Results", f"No emails found with Trade ID: {trade_id}")
            else:
                messagebox.showinfo("Success", f"Found {len(found_emails)} emails with Trade ID: {trade_id}")
                
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {str(e)}")
        finally:
            self.progress.stop()
            
    def extract_tables_from_html(self, html_content):
        tables = []
        try:
            soup = BeautifulSoup(html_content, 'html.parser')
            for table in soup.find_all('table'):
                # Extract table data
                table_data = []
                for row in table.find_all('tr'):
                    cols = row.find_all(['td', 'th'])
                    cols = [col.text.strip() for col in cols]
                    if cols:
                        table_data.append(cols)
                
                if table_data:
                    tables.append(table_data)
        except Exception as e:
            print(f"Error extracting tables: {e}")
        return tables
    
    def extract_text_content(self, plain_text, html_content):
        if plain_text:
            return plain_text
        
        if html_content:
            try:
                soup = BeautifulSoup(html_content, 'html.parser')
                return soup.get_text(separator='\n')
            except:
                return html_content
                
        return ""
    
    def on_email_select(self, event):
        selection = self.tree.selection()
        if not selection:
            return
            
        item = self.tree.item(selection[0])
        subject = item['values'][0]
        
        # Find the selected email in our stored data
        selected_email = None
        for email in self.emails:
            if email['subject'].startswith(subject.replace("...", "")):
                selected_email = email
                break
                
        if selected_email:
            # Display email content
            content = f"From: {selected_email['sender']}\n"
            content += f"Date: {selected_email['date']}\n"
            content += f"Subject: {selected_email['subject']}\n"
            content += f"Trade ID: {selected_email['trade_id']}\n"
            content += "-" * 50 + "\n"
            content += selected_email['body']
            
            # Add table information
            if selected_email['tables']:
                content += f"\n\nFound {len(selected_email['tables'])} table(s) in this email."
                
            self.content_text.delete(1.0, tk.END)
            self.content_text.insert(1.0, content)
    
    def clear_results(self):
        self.tree.delete(*self.tree.get_children())
        self.content_text.delete(1.0, tk.END)
        self.emails = []
    
    def export_to_csv(self):
        if not self.emails:
            messagebox.showwarning("No Data", "No emails to export")
            return
            
        try:
            # Create a DataFrame from the extracted emails
            data = []
            for email in self.emails:
                # Flatten tables into a string representation
                tables_str = ""
                for i, table in enumerate(email['tables']):
                    tables_str += f"Table {i+1}: {len(table)} rows, {len(table[0]) if table else 0} columns; "
                
                data.append({
                    'Subject': email['subject'],
                    'From': email['sender'],
                    'Date': email['date'],
                    'Trade ID': email['trade_id'],
                    'Body Preview': email['body'][:100] + "..." if len(email['body']) > 100 else email['body'],
                    'Tables': tables_str
                })
            
            df = pd.DataFrame(data)
            
            # Save to CSV
            filename = f"trade_emails_{self.trade_id_var.get()}.csv"
            df.to_csv(filename, index=False)
            
            messagebox.showinfo("Success", f"Data exported to {filename}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export data: {str(e)}")

if __name__ == "__main__":
    root = tk.Tk()
    app = OutlookEmailExtractor(root)
    root.mainloop()
